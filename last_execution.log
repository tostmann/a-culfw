* feature/esp32-support
  master
diff --git a/culfw/Devices/ESP32/main.cpp b/culfw/Devices/ESP32/main.cpp
new file mode 100644
index 0000000..4625320
--- /dev/null
+++ b/culfw/Devices/ESP32/main.cpp
@@ -0,0 +1,193 @@
+#include <Arduino.h>
+#include "board.h"
+#include "hal_gpio.h"
+#include "hal_spi.h"
+#include "hal_timer.h"
+
+extern "C" {
+#include "delay.h"
+#include "clock.h"
+#include "rf_receive.h"
+#include "rf_send.h"
+#include "cc1100.h"
+#include "ttydata.h"
+#include "ringbuffer.h"
+#include "fncollection.h"
+#include "display.h"
+#include "fastrf.h"
+#include "fband.h"
+#include "rf_mode.h"
+#include "version.h"
+#include "fht.h"
+
+extern volatile uint32_t gdo_isr_count;
+
+#ifdef HAS_ASKSIN
+#include "rf_asksin.h"
+#endif
+#ifdef HAS_MORITZ
+#include "rf_moritz.h"
+#endif
+#ifdef HAS_RWE
+#include "rf_rwe.h"
+#endif
+#ifdef HAS_RFNATIVE
+#include "rf_native.h"
+#endif
+#ifdef HAS_INTERTECHNO
+#include "intertechno.h"
+#endif
+#ifdef HAS_SOMFY_RTS
+#include "somfy_rts.h"
+#endif
+#ifdef HAS_MBUS
+#include "rf_mbus.h"
+#endif
+
+void eeprom_init(void);
+
+// Function table
+extern const t_fntab fntab[];
+
+void hal_enable_CC_GDOin_int(uint8_t cc_num, uint8_t enable);
+}
+
+#define rb_is_empty(rb) ((rb)->nbytes == 0)
+
+// Function table definition
+extern "C" const t_fntab fntab[] = {
+  { 'C', ccreg },
+  { 'F', fs20send },
+#ifdef HAS_INTERTECHNO
+  { 'i', it_func },
+#endif
+#ifdef HAS_ASKSIN
+  { 'A', asksin_func },
+#endif
+#ifdef HAS_MORITZ
+  { 'Z', moritz_func },
+#endif
+#ifdef HAS_RFNATIVE
+  { 'N', native_func },
+#endif
+#ifdef HAS_RWE
+  { 'E', rwe_func },
+#endif
+  { 'R', read_eeprom },
+  { 'T', fhtsend },
+  { 'V', version },
+  { 'W', write_eeprom },
+  { 'X', set_txreport },
+  { 'e', eeprom_factory_reset },
+#ifdef HAS_FASTRF
+  { 'f', fastrf_func },
+#endif
+  { 'l', ledfunc },
+  { 't', gettime },
+  { 'x', ccsetpa },
+#ifdef HAS_MBUS
+  { 'b', rf_mbus_func },
+#endif
+#ifdef HAS_SOMFY_RTS
+  { 'Y', somfy_rts_func },
+#endif
+  { 0, 0 },
+};
+
+void setup() {
+    // On ESP32-C3/C6, with USB_CDC_ON_BOOT=1, Serial is the USB CDC.
+    // If it doesn't work, we try to use USBSerial directly.
+    Serial.begin(115200);
+    
+    HAL_LED_Init();
+    // Blink LED on startup
+    for(int i=0; i<3; i++) {
+        HAL_LED_Set(LED0, LED_on);
+        delay(100);
+        HAL_LED_Set(LED0, LED_off);
+        delay(100);
+    }
+    
+    Serial.println("\r\n--- CULFW32 ESP32 Starting ---");
+    Serial.print("Board: "); Serial.println(BOARD_NAME);
+    
+    hal_timer_init();
+    eeprom_init();
+    
+    rb_reset(&TTY_Rx_Buffer);
+    rb_reset(&TTY_Tx_Buffer);
+    
+    input_handle_func = analyze_ttydata;
+    display_channel = DISPLAY_USB;
+    
+    spi_init();
+    ccInitChip(EE_CC1100_CFG);
+    tx_init();
+    
+    // Explicitly enable GDO interrupt AFTER initialization
+    hal_enable_CC_GDOin_int(0, 1);
+    
+    Serial.println("Ready.");
+}
+
+void loop() {
+    static uint32_t last_isr_count = 0;
+    static unsigned long last_debug_print = 0;
+
+    if (millis() - last_debug_print > 1000) {
+        if (gdo_isr_count != last_isr_count) {
+             Serial.print("ISR Count: ");
+             Serial.println(gdo_isr_count);
+             last_isr_count = gdo_isr_count;
+        }
+        last_debug_print = millis();
+    }
+
+    // 1. Read from Serial into Rx Buffer
+    while (Serial.available()) {
+        uint8_t c = Serial.read();
+        rb_put(&TTY_Rx_Buffer, c);
+    }
+    
+    // 2. Process Commands
+    if (!rb_is_empty(&TTY_Rx_Buffer)) {
+        analyze_ttydata(DISPLAY_USB);
+    }
+    
+    // 3. Background Tasks
+    Minute_Task();
+    RfAnalyze_Task();
+    
+#ifdef HAS_FASTRF
+    FastRF_Task();
+#endif
+#ifdef HAS_ASKSIN
+    rf_asksin_task();
+#endif
+#ifdef HAS_MORITZ
+    rf_moritz_task();
+#endif
+#ifdef HAS_RWE
+    rf_rwe_task();
+#endif
+#ifdef HAS_MBUS
+    rf_mbus_task();
+#endif
+#ifdef HAS_RFNATIVE
+    native_task();
+#endif
+
+    // 4. Write from Tx Buffer to Serial
+    while (!rb_is_empty(&TTY_Tx_Buffer)) {
+        if (Serial.availableForWrite() > 0) {
+            Serial.write(rb_get(&TTY_Tx_Buffer));
+        } else {
+            // Check if we are connected, otherwise discard to prevent hang
+            // On ESP32 USB CDC, availableForWrite() might return 0 if no host is listening
+            break; 
+        }
+    }
+    
+    // Allow ESP32 system tasks (Watchdog, etc)
+    yield();
+}
diff --git a/culfw/ESP32/hal.cpp b/culfw/ESP32/hal.cpp
new file mode 100644
index 0000000..24bba00
--- /dev/null
+++ b/culfw/ESP32/hal.cpp
@@ -0,0 +1,201 @@
+#include <Arduino.h>
+#include <SPI.h>
+#include <EEPROM.h>
+#include "hal_gpio.h"
+#include "hal_spi.h"
+#include "hal_timer.h"
+#include "board.h"
+
+extern "C" volatile uint32_t ticks = 0;
+extern "C" uint8_t SREG = 0;
+extern "C" uint8_t TIMSK0 = 0;
+volatile uint32_t gdo_isr_count = 0;
+
+extern "C" {
+#include "delay.h"
+#include "rf_receive.h"
+
+// Forward declarations of CULFW functions
+void rf_receive_TimerElapsedCallback(void);
+void CC1100_in_callback(void);
+}
+
+void IRAM_ATTR gdo_interrupt_handler();
+
+// Timer for system ticks (1ms)
+static hw_timer_t * tick_timer = NULL;
+void IRAM_ATTR onTickTimer() {
+    ticks++;
+}
+
+// Timer for RF Silence timeout
+static hw_timer_t * rf_timer = NULL;
+static volatile uint32_t rf_reload_val = 0;
+static bool rf_timer_enabled = false;
+
+void IRAM_ATTR onRfTimer() {
+    rf_receive_TimerElapsedCallback();
+}
+
+void hal_timer_init(void) {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+    tick_timer = timerBegin(1000000); // 1MHz
+    timerAttachInterrupt(tick_timer, &onTickTimer);
+    timerAlarm(tick_timer, 1000, true, 0); // 1ms
+    
+    rf_timer = timerBegin(1000000); // 1MHz
+    timerAttachInterrupt(rf_timer, &onRfTimer);
+#else
+    tick_timer = timerBegin(0, 80, true); // 1MHz
+    timerAttachInterrupt(tick_timer, &onTickTimer, true);
+    timerAlarmWrite(tick_timer, 1000, true);
+    timerAlarmEnable(tick_timer);
+
+    rf_timer = timerBegin(1, 80, true); // 1MHz
+    timerAttachInterrupt(rf_timer, &onRfTimer, true);
+#endif
+}
+
+uint32_t hal_get_ticks(void) {
+    return ticks;
+}
+
+// RF Timer HAL
+void hal_enable_CC_timer_int(uint8_t instance, uint8_t enable) {
+    if (enable) {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+        timerAlarm(rf_timer, rf_reload_val, false, 0);
+        timerStart(rf_timer);
+#else
+        timerAlarmWrite(rf_timer, rf_reload_val, false);
+        timerAlarmEnable(rf_timer);
+        timerStart(rf_timer);
+#endif
+        rf_timer_enabled = true;
+    } else {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+        timerStop(rf_timer);
+#else
+        timerAlarmDisable(rf_timer);
+        timerStop(rf_timer);
+#endif
+        rf_timer_enabled = false;
+    }
+}
+
+uint32_t HAL_timer_get_reload_register(uint8_t instance) {
+    return rf_reload_val;
+}
+
+void HAL_timer_set_reload_register(uint8_t instance, uint32_t value) {
+    rf_reload_val = value;
+    if (rf_timer_enabled) {
+        hal_enable_CC_timer_int(instance, true);
+    }
+}
+
+static uint32_t rf_counter_offset = 0;
+uint32_t HAL_timer_get_counter_value(uint8_t instance) {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+    return (uint32_t)timerRead(rf_timer) - rf_counter_offset;
+#else
+    return timerRead(rf_timer) - rf_counter_offset;
+#endif
+}
+
+void HAL_timer_set_counter_value(uint8_t instance, uint32_t value) {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+    rf_counter_offset = (uint32_t)timerRead(rf_timer) - value;
+#else
+    rf_counter_offset = timerRead(rf_timer) - value;
+#endif
+}
+
+void HAL_timer_reset_counter_value(uint8_t instance) {
+#if ESP_ARDUINO_VERSION_MAJOR >= 3
+    timerWrite(rf_timer, 0);
+#else
+    timerWrite(rf_timer, 0);
+#endif
+    rf_counter_offset = 0;
+}
+
+// GPIO stuff
+void HAL_LED_Init(void) {
+    pinMode(LED_PIN, OUTPUT);
+}
+
+void HAL_LED_Set(LED_List led, LED_State state) {
+    digitalWrite(LED_PIN, state == LED_on ? HIGH : LOW);
+}
+
+void HAL_LED_Toggle(LED_List led) {
+    digitalWrite(LED_PIN, !digitalRead(LED_PIN));
+}
+
+void IRAM_ATTR gdo_interrupt_handler() {
+    gdo_isr_count++;
+    CC1100_in_callback();
+}
+
+void hal_CC_GDO_init(uint8_t cc_num, uint8_t mode) {
+    pinMode(GDO0_PIN, INPUT_PULLUP);
+    pinMode(GDO2_PIN, INPUT);
+    // Interrupt will be enabled explicitly later or via hal_enable_CC_GDOin_int
+}
+
+void hal_enable_CC_GDOin_int(uint8_t cc_num, uint8_t enable) {
+    if (enable) {
+        attachInterrupt(digitalPinToInterrupt(GDO0_PIN), gdo_interrupt_handler, CHANGE);
+    } else {
+        detachInterrupt(digitalPinToInterrupt(GDO0_PIN));
+    }
+}
+
+void hal_CC_Pin_Set(uint8_t cc_num, CC_PIN pin, uint8_t state) {
+    if (pin == CC_Pin_CS) {
+        digitalWrite(CC1100_CS_PIN, state);
+    }
+}
+
+uint32_t hal_CC_Pin_Get(uint8_t cc_num, CC_PIN pin) {
+    if (pin == CC_Pin_In) {
+        return digitalRead(GDO0_PIN);
+    }
+    return 0;
+}
+
+// SPI stuff
+void spi_init(void) {
+    SPI.begin(SPI_SCLK, SPI_MISO, SPI_MOSI, SPI_SS);
+    pinMode(SPI_SS, OUTPUT);
+    digitalWrite(SPI_SS, HIGH);
+}
+
+uint8_t spi_send(uint8_t data) {
+    return SPI.transfer(data);
+}
+
+// Delay
+extern "C" void my_delay_ms(uint8_t ms) {
+    delay(ms);
+}
+
+extern "C" void my_delay_us(uint16_t us) {
+    delayMicroseconds(us);
+}
+
+// EEPROM emulation
+extern "C" void hal_eeprom_init(void) {
+    if (!EEPROM.begin(512)) {
+    }
+}
+
+extern "C" uint8_t eeprom_read_byte(uint8_t *addr) {
+    return EEPROM.read((size_t)addr);
+}
+
+extern "C" void eeprom_write_byte(uint8_t *addr, uint8_t value) {
+    EEPROM.write((size_t)addr, value);
+    EEPROM.commit();
+}
